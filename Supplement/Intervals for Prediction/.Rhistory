summary(mod)
mod = lm(adj_fatal~yd,data=fatal)
summary(mod)
#We have found significance. Hooray!!. Let's visualize the model.
plot(adj_fatal~yd,data=fatal)
abline(mod)
anova(adj_fatal~yd,data=fatal)
anova(mod,data=fatal)
anova(mod,data=fatal)
#Model for the relationship between fatalities and proportion of young drivers.
#Create new variable for youngdrivers to help interpretation of slope
fatal$yd=fatal$youngdrivers*100
mod = lm(adj_fatal~youngdrivers,data=fatal)
summary(mod)
mod = lm(adj_fatal~yd,data=fatal)
summary(mod)
#We have found significance. Hooray!!. Let's visualize the model.
plot(adj_fatal~yd,data=fatal)
abline(mod)
confint(mod)
anova(mod,data=fatal)
1.41e-05
#This code chunk is for modifying the global options and for loading required R packages
knitr::opts_chunk$set(echo = TRUE)
options(scipen=999) #Prevents the use of scientific notation
library(rmarkdown)
library(tinytex)
library(knitr)
library(readr)
library(mosaic) #Install Mosaic Package
library(AER)
data("Fatalities") # Load Data
fatal = Fatalities[,c("fatal","pop","youngdrivers")]
head(fatal)
#Consider scatterplot
plot(x=fatal$pop,y=fatal$fatal)
#Create New Variable Called adj_fatal
fatal$adj_fatal = (fatal$fatal/fatal$pop)*1000
#Remove Original Variable
fatal$fatal = NULL
#Preview Modified Dataset
head(fatal)
#Consider new scatterplot
plot(x=fatal$pop,y=fatal$adj_fatal)
#Model for the relationship between fatalities and proportion of young drivers.
#Create new variable for youngdrivers to help interpretation of slope
fatal$yd=fatal$youngdrivers*100
mod = lm(adj_fatal~youngdrivers,data=fatal)
summary(mod)
mod = lm(adj_fatal~yd,data=fatal)
summary(mod)
#We have found significance. Hooray!!. Let's visualize the model.
plot(adj_fatal~yd,data=fatal)
abline(mod)
1.41e-05
View(fatal)
View(fatal)
mean(fatal$pop)
mean(fatal$youngdrivers
mean(fatal$youngdrivers)
mean(fatal$youngdrivers)
mean(fatal$yd)
mean(fatal$adj_fatal)
anova(modlego2)
library(readr)
library(Stat2Data)
lego <- read_csv("https://raw.githubusercontent.com/JA-McLean/STOR455/master/data/lego.csv")
lego_under_800_pieces = subset(lego, Pieces < 800)
modlego2 = lm(Amazon_Price^(0.3)~Pieces, data=lego_under_800_pieces)
plot(Amazon_Price^(0.3)~Pieces, data=lego_under_800_pieces)
abline(modlego2, col="red")
summary(modlego2)
plot(modlego2, c(1, 2, 5))
cor(lego_under_800_pieces$Pieces, lego_under_800_pieces$Amazon_Price^(0.3))
cor(
lego_under_800_pieces$Pieces,
lego_under_800_pieces$Amazon_Price^(0.3),
use="complete.obs"
)
data(Houses)
head(Houses)
cor(Houses)
data(Cereal)
head(Cereal)
#cor(Cereal)
cor(Cereal[c(2:4)])
cor.test(lego_under_800_pieces$Pieces, lego_under_800_pieces$Amazon_Price^(0.3))
cor(lego_under_800_pieces$Pieces, lego_under_800_pieces$Amazon_Price^(0.3))
cor(
lego_under_800_pieces$Pieces,
lego_under_800_pieces$Amazon_Price^(0.3),
use="complete.obs"
)
data(Houses)
head(Houses)
cor(Houses)
anova(modlego2)
confint(mod)
#Model for the relationship between fatalities and proportion of young drivers.
#Create new variable for youngdrivers to help interpretation of slope
fatal$yd=fatal$youngdrivers*100
mod = lm(adj_fatal~youngdrivers,data=fatal)
summary(mod)
mod = lm(adj_fatal~yd,data=fatal)
summary(mod)
#We have found significance. Hooray!!. Let's visualize the model.
plot(adj_fatal~yd,data=fatal)
abline(mod)
1.41e-05
anova(mod,data=fatal)
anova(mod)
anova(mod)
#Hand Calculation of SST
sum((fatal$adj_fatal-mean(fatal$adj_fatal))^2)
#Notice that this equals the sum from the ANOVA table
0.0598+1.02930
#Hand Calculation of SST
sum((fatal$adj_fatal-mean(fatal$adj_fatal))^2)
#Notice that this equals the sum from the ANOVA table
0.0598+1.02930
summary(mod)
#Manually calculate p-value using the t-distribution
pt(0.5,334,lower.tail=T)
#Manually calculate p-value using the t-distribution
pt(0,334,lower.tail=T)
summary(mod)
qt(0.5,334)
qt(0,334)
qt(0.1,334)
pt(4.407,334,lower.tail=F)
#Manually calculate p-value using the t-distribution
pt(4.407,334,lower.tail=T) #Find area to right and multiply by 2
2*(1-pt(4.407,334,lower.tail=T))
summary(mod)
anova(mod)
#Manually find the p-value and check it matches
pf(19.422,1,334,lower.tail=FALSE) #Want the area to the right of 19.422
#This code chunk is for modifying the global options and for loading required R packages
knitr::opts_chunk$set(echo = TRUE)
options(scipen=999) #Prevents the use of scientific notation
library(rmarkdown)
library(tinytex)
library(knitr)
library(readr)
library(mosaic) #Install Mosaic Package
library(AER)
#Consider scatterplot
plot(x=fatal$pop,y=fatal$fatal)
#Create New Variable Called adj_fatal
fatal$adj_fatal = (fatal$fatal/fatal$pop)*1000
#This code chunk is for modifying the global options and for loading required R packages
knitr::opts_chunk$set(echo = TRUE)
options(scipen=999) #Prevents the use of scientific notation
library(rmarkdown)
library(tinytex)
library(knitr)
library(readr)
library(mosaic) #Install Mosaic Package
library(AER)
data("Fatalities") # Load Data
fatal = Fatalities[,c("fatal","pop","youngdrivers")]
fatal$adj_fatal = (fatal$fatal/fatal$pop)*1000
fatal$yd=fatal$youngdrivers*100
head(fatal)
data("Fatalities") # Load Data
fatal = Fatalities[,c("fatal","pop","youngdrivers")]
fatal$adj_fatal = (fatal$fatal/fatal$pop)*1000
fatal$yd=fatal$youngdrivers*100
fatal$fatal=NULL
fatal$pop=NULL
fatal$youngdrivers=NULL
head(fatal)
anova(mod)
#Fit Linear Regression Model
mod = lm(adj_fatal~yd,data=fatal)
#Fit Linear Regression Model
mod = lm(adj_fatal~yd,data=fatal)
#Results from t-test for slope
summary(mod)
#Results from ANOVA F-test for Effectiveness of SLR Model
anova(mod)
#Relationship between test statistivs between both tests
out=summary(mod)
out$coefficients
out$coefficients[2,3]
summary.out$coefficients[2,3]
#Relationship between test statistivs between both tests
summary.out=summary(mod)
summary.out$coefficients[2,3]
summary.out$fstatistic
summary.out$fstatistic[1]
tstat^2
#Relationship between test statistivs between both tests
summary.out=summary(mod)
tstat=summary.out$coefficients[2,3]
Fstat=summary.out$fstatistic[1]
tstat^2
Fstat
tstat^2
Fstat
tstat^2
Fstat
Fstat=summary.out$fstatistic
summary.out$fstatistic
summary.out$fstatistic$value
Fstat=summary.out$fstatistic[1]
summary.out$fstatistic[1]
Fstat=as.numeric(summary.out$fstatistic[1])
tstat^2
Fstat
as.numeric(summary.out$fstatistic[1])
as.numeric(summary.out$fstatistic[1])
as.numeric(summary.out$fstatistic[1])
# Correlation Test
cor.test(x=fatal$adj_fatal,y=fatal$yd)
cor.test(y=fatal$adj_fatal,x=fatal$yd)
# Correlation Test
cor.test(x=fatal$adj_fatal,y=fatal$yd)
cor.test(y=fatal$adj_fatal,x=fatal$yd)
# R-squared
summary.out$r.squared
cor(x=fatal$adj_fatal,y=fatal$yd)
# R-squared
cor(x=fatal$adj_fatal,y=fatal$yd)^2
summary.out$r.squared
unknown = data.frame(yd=c(0.2))
unknown
summary.out$coefficients
summary.out$coefficients$Estimate
summary.out$coefficients
summary.out$coefficients[2,1]
xstar=0.2
fit.yint = summary.out$coefficients[1,1]
fit.slope = summary.out$coefficients[2,1]
fit.yint+fit.slope*xstar
qt(0.975, 716)
curve(
dt.scaled(
x,
716,
mean = summary(modlego2)$coef[2,1],
sd = summary(modlego2)$coef[2,2]
),
from = 0.00190, to = 0.00255,
)
library(readr)
library(Stat2Data)
library(metRology)
library(tidyr)
lego <- read_csv("https://raw.githubusercontent.com/JA-McLean/STOR455/master/data/lego.csv")
lego_under_800_pieces = subset(lego, Pieces < 800)
source("https://raw.githubusercontent.com/JA-McLean/STOR455/master/scripts/CIPIPlot.R")
modlego = lm(Amazon_Price~Pieces, data=lego_under_800_pieces)
plot(Amazon_Price~Pieces, data=lego_under_800_pieces)
abline(modlego, col="red")
summary(modlego)
plot(modlego, c(1, 2, 5))
modlego2 = lm(Amazon_Price^(0.3)~Pieces, data=lego_under_800_pieces)
plot(Amazon_Price^(0.3)~Pieces, data=lego_under_800_pieces)
abline(modlego2, col="red")
summary(modlego2)
plot(modlego2, c(1, 2, 5))
plot(Amazon_Price~Pieces, data=lego_under_800_pieces)
B0 = summary(modlego2)$coef[1,1]
B1 = summary(modlego2)$coef[2,1]
curve((B0 + B1*x)^(10/3), add=TRUE, col='red')
dataframe_to_write = lego_under_800_pieces %>% drop_na('Pieces', 'Amazon_Price')
dataframe_to_write$Amazon_Price_transformed = dataframe_to_write$Amazon_Price^0.3
write.csv(dataframe_to_write,
file = "lego_under_800_pieces.csv",
row.names=FALSE
)
#Are We Extrapolating?
quantile(x=fatal$yd)
boxplot(x=fatal$yd)
predict(mod,newdata=unknown)
#Are We Extrapolating?
quantile(x=fatal$yd)
#Alternative Way to predict when yd=0.2 or yd=0.15
unknown = data.frame(yd=c(0.2))
predict(mod,newdata=unknown)
#Alternative Way to predict when yd=0.2 or yd=0.15
unknown = data.frame(yd=c(0.2,0.15))
predict(mod,newdata=unknown)
#Plot of predictions
plot(x=yd,y=adj_fatal,data=fatal)
#Are We Extrapolating?
quantile(x=fatal$yd)
boxplot(x=fatal$yd)
#Predict when yd=0.2
xstar=0.2
fit.yint = summary.out$coefficients[1,1]
fit.slope = summary.out$coefficients[2,1]
fit.yint+fit.slope*xstar
#Alternative Way to predict when yd=0.2 or yd=0.15
unknown = data.frame(yd=c(0.2,0.15))
predict(mod,newdata=unknown)
#Plot of predictions
plot(x=yd,y=adj_fatal,data=fatal)
#Plot of predictions
plot(x=yd,y=adj_fatal,data=fatal)
#Plot of predictions
plot(adj_fatal~yd,data=fatal)
abline(mod)
modlego2 = lm(Amazon_Price^(0.3)~Pieces, data=lego_under_800_pieces)
plot(Amazon_Price^(0.3)~Pieces, data=lego_under_800_pieces)
abline(modlego2, col="red")
summary(modlego2)
plot(modlego2, c(1, 2, 5))
plot(Amazon_Price~Pieces, data=lego_under_800_pieces)
B0 = summary(modlego2)$coef[1,1]
B1 = summary(modlego2)$coef[2,1]
curve((B0 + B1*x)^(10/3), add=TRUE, col='red')
plot(adj_fatal~yd,data=fatal)
abline(mod)
points(x=0.2,y=0.105,pch=12)
plot(adj_fatal~yd,data=fatal)
abline(mod)
points(x=0.2,y=0.105,pch=12)
plot(adj_fatal~yd,data=fatal)
abline(mod)
points(x=0.2,y=0.105,pch=12)
plot(adj_fatal~yd,data=fatal)
abline(mod)
points(x=0.2,y=0.105,pch=12)
plot(adj_fatal~yd,data=fatal)
abline(mod)
points(x=0.2,y=0.105,pch=12,cex=5)
plot(adj_fatal~yd,data=fatal)
abline(mod)
points(x=0.2,y=0.105,pch=12,cex=5)
plot(adj_fatal~yd,data=fatal)
abline(mod)
points(x=0.2,y=0.105,pch=12,cex=5)
points(x=0.2,y=0.105,pch=12,cex=5,add=TRUE)
plot(adj_fatal~yd,data=fatal)
abline(mod)
points(x=0.2,y=0.105,pch=12,cex=5,add=TRUE)
points(x=0.2,y=0.105,pch=12,cex=5,add=TRUE)
#Are We Extrapolating?
quantile(x=fatal$yd)
boxplot(x=fatal$yd)
#Predict when yd=0.2
xstar=0.2
fit.yint = summary.out$coefficients[1,1]
fit.slope = summary.out$coefficients[2,1]
fit.yint+fit.slope*xstar
#Alternative Way to predict when yd=0.2 or yd=0.15
unknown = data.frame(yd=c(0.2,0.15))
predict(mod,newdata=unknown)
#Plot of predictions
plot(adj_fatal~yd,data=fatal)
abline(mod)
points(x=0.2,y=0.105,pch=17,cex=5,add=TRUE)
#Are We Extrapolating?
quantile(x=fatal$yd)
boxplot(x=fatal$yd)
#Predict when yd=0.2
xstar=0.2
fit.yint = summary.out$coefficients[1,1]
fit.slope = summary.out$coefficients[2,1]
fit.yint+fit.slope*xstar
#Alternative Way to predict when yd=20 or yd=0.15
unknown = data.frame(yd=c(0.2,0.15))
predict(mod,newdata=unknown)
#Plot of predictions
plot(adj_fatal~yd,data=fatal)
abline(mod)
points(x=20,y=0.105,pch=17,cex=5,add=TRUE)
#Are We Extrapolating?
quantile(x=fatal$yd)
boxplot(x=fatal$yd)
#Predict when yd=0.2
xstar=20
fit.yint = summary.out$coefficients[1,1]
fit.slope = summary.out$coefficients[2,1]
fit.yint+fit.slope*xstar
#Alternative Way to predict when yd=20 or yd=15
unknown = data.frame(yd=c(20,15))
predict(mod,newdata=unknown)
#Plot of predictions
plot(adj_fatal~yd,data=fatal)
abline(mod)
points(x=20,y=0.105,pch=17,cex=5,add=TRUE)
fit.yint+fit.slope*xstar
xstar=20
fit.yint = summary.out$coefficients[1,1]
fit.slope = summary.out$coefficients[2,1]
fit.yint+fit.slope*xstar
#Are We Extrapolating?
quantile(x=fatal$yd)
boxplot(x=fatal$yd)
#Predict when yd=0.2
xstar=20
fit.yint = summary.out$coefficients[1,1]
fit.slope = summary.out$coefficients[2,1]
fit.yint+fit.slope*xstar
#Alternative Way to predict when yd=20 or yd=15
unknown = data.frame(yd=c(20,15))
predict(mod,newdata=unknown)
#Plot of predictions
plot(adj_fatal~yd,data=fatal)
abline(mod)
points(x=20,y=0.2116054,pch=17,cex=5,add=TRUE)
#Are We Extrapolating?
quantile(x=fatal$yd)
boxplot(x=fatal$yd)
#Predict when yd=0.2
xstar=20
fit.yint = summary.out$coefficients[1,1]
fit.slope = summary.out$coefficients[2,1]
fit.yint+fit.slope*xstar
#Alternative Way to predict when yd=20 or yd=15
unknown = data.frame(yd=c(20,15))
predict(mod,newdata=unknown)
#Plot of predictions
plot(adj_fatal~yd,data=fatal)
abline(mod)
points(x=20,y=0.2116054,pch=17,cex=3,add=TRUE)
#Alternative Way to predict when yd=20 or yd=15
unknown = data.frame(yd=c(20,15))
predict(mod,newdata=unknown)
plot(adj_fatal~yd,data=fatal)
abline(mod)
points(x=c(20,15),y=predict(mod,newdata=unknown),pch=17,cex=3,add=TRUE)
plot(adj_fatal~yd,data=fatal)
abline(mod)
points(x=c(20,15),y=predict(mod,newdata=unknown),pch=17,cex=3)
dataframe_to_write = lego_under_800_pieces %>% drop_na('Pieces', 'Amazon_Price')
dataframe_to_write$Amazon_Price_transformed = dataframe_to_write$Amazon_Price^0.3
write.csv(dataframe_to_write,
file = "lego_under_800_pieces.csv",
row.names=FALSE
)
# Display the Student's t distributions with various
# degrees of freedom and compare to the normal distribution
x <- seq(-4, 4, length=100)
hx <- dnorm(x)
degf <- c(1, 5, 15, 30)
colors <- c("red", "blue", "darkgreen", "gold", "black")
labels <- c("df=1", "df=5", "df=15", "df=30", "normal")
plot(x, hx, type="l", lty=2, xlab="x value",
ylab="Density", main="Comparison of t Distributions")
for (i in 1:4){
lines(x, dt(x,degf[i]), lwd=2, col=colors[i])
}
legend("topright", inset=.05, title="Distributions",
labels, lwd=2, lty=c(1, 1, 1, 1, 2), col=colors)
qt(0.975, 716)
curve(
dt.scaled(
x,
716,
mean = summary(modlego2)$coef[2,1],
sd = summary(modlego2)$coef[2,2]
),
from = 0.00190, to = 0.00255,
)
abline(
v=c(
qt.scaled(
0.025,
716,
mean = summary(modlego2)$coef[2,1],
sd = summary(modlego2)$coef[2,2]
),
qt.scaled(
0.975,
716,
mean = summary(modlego2)$coef[2,1],
sd = summary(modlego2)$coef[2,2]
)
)
)
predict.lm(modlego2, newx, interval="confidence")^(10/3)
CIPIPlot(lego_under_800_pieces$Pieces, lego_under_800_pieces$Amazon_Price^(0.3))
#This code chunk is for modifying the global options and for loading required R packages
knitr::opts_chunk$set(echo = TRUE)
options(scipen=999) #Prevents the use of scientific notation
library(rmarkdown)
library(tinytex)
library(knitr)
library(readr)
library(mosaic) #Install Mosaic Package
library(AER)
library(metRology) #Install metRology Package
summary(modlego2)$coef[2,1]-qt(0.975, 716)*summary(modlego2)$coef[2,2]
summary(modlego2)$coef[2,1]+qt(0.975, 716)*summary(modlego2)$coef[2,2]
confint(modlego2, level=0.95)
predict(mod,unknown,interval="Confidence")
predict(mod,unknown,interval="confidence")
predict(mod,unknown,interval="prediction")
predict(mod,unknown,interval="confidence")
predict(mod,unknown,interval="prediction")
predict(mod,newdata=unknown)
CIPIPlot(fatal$yd, fatal$adj_fatal)
CIPIPlot(fatal$yd, fatal$adj_fatal)
CIPIPlot(fatal$yd, fatal$adj_fatal)
library(metRology)
#This code chunk is for modifying the global options and for loading required R packages
knitr::opts_chunk$set(echo = TRUE)
options(scipen=999) #Prevents the use of scientific notation
library(rmarkdown)
library(tinytex)
library(knitr)
library(readr)
library(mosaic) #Install Mosaic Package
library(AER)
source("https://raw.githubusercontent.com/JA-McLean/STOR455/master/scripts/CIPIPlot.R")
CIPIPlot
CIPIPlot
CIPIPlot(fatal$yd, fatal$adj_fatal)
